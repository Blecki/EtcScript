
EtcScript Grammar

Script				:= (MacroDeclaration | RuleDeclaration | TypeDeclaration)*
MacroDeclaration	:= "macro" + DeclarationHeader + Block + (: + Identifier)?
DeclarationHeader	:= (DeclarationTerm)*
RuleDeclaration		:= "rule" + DeclarationHeader + WhenClause? + Block
WhenClause			:= "when" + Expression
DeclarationTerm		:= Identifier | String | ( "(" + Identifier + (: + Identifier)? + ")" + RepetitionMarker? )
Identifier			:= [a-z, A-Z, any non-operator symbol][any non-delimeter symbol]*
RepetitionMarker	:= "?" | "*" | "+"
Block				:= { + Statement+ + }
Statement			:= Let | If | Invokation + ; | DynamicInvokation + ; | BracketInvokation + ; | Control | LocalDeclaration
Let					:= "let" + (Identifier | MemberAccess) + "=" + Expression + ;
If					:= "if" + Expression + Block
MemberAccess		:= Term + (StaticMember | DynamicMember)
StaticMember		:= "." + Identifier
DynamicMember		:= "?" + Identifier + ":" + Term
Expression			:= Term | BinaryOperation | New
Term				:= Parenthetical | Identifier | Number | BasicString | ComplexString 
						| MemberAccess | BracketInvokation | DynamicInvokation
Parenthetical		:= "(" + Expression + ")"
BinaryOperation		:= Term + Operator + Term
Invokation			:= Term+
BracketInvokation	:= "[" + Invokation + "]"
DynamicInvokation	:= ":" + BracketInvokation
Control				:= Invokation + (Block | ;)
Operator			:= Any of operators specified in operator table
BasicString			:= Ordinary quote-delimited string
ComplexString		:= \" + ( Text | EmbeddedExpression )* + \"
Text				:= Any sequence of characters except [ or ", matched greedily.
EmbeddedExpression	:= [ + Expression + ]
LocalDeclaration	:= "var" + Identifier + (: + Identifier)? + ("=" + Expression)? + ;
TypeDeclaration		:= "type" + Identifier + { + MemberDeclaration* + }
MemberDeclaration	:=  "var" + Identifier + (: + Identifier)? + ;
New					:= "new" + Identifier

Delimeter symbols	:= []{}()\s\t\r\n.:;

Default operator table
0	||
0	&&
0	==
0	!=
0	<
0	>
0	<=
0	>=

1	+
1	-
1	&
1	|

2	*
2	/
2	%

Default Controls

foreach (x) in (list)
foreach (x) from (min) to (max)
while (x)

