TODO List:
	Github page w/ examples
	IDE or line-by-line debugger?
	Namespaces?
	String Library + Documentation
	RTTI implementation may enable implementation of an 'is-a' operator or a checked cast.
	Make a table of system functions and refer to them by index in generated bytecode
	Globals infer type from assignment
	Reference globals in rule terms. Compile to an equality comparison against the global.
		Globals must be type-resolved before rules.
		Additional term type needed, which must only be allowed for rules.

EtcScript Grammar

Script				:= (MacroDeclaration | RuleDeclaration | TypeDeclaration | GlobalDeclaration | Include)*
GlobalDeclaration	:= "global" + Identifier + (: + Identifier)? + (= + Expression)? + ;
MacroDeclaration	:= "macro" + DeclarationHeader + (: + Identifier)? + Block
DeclarationHeader	:= (DeclarationTerm)*
RuleDeclaration		:= "rule" + DeclarationHeader + WhenClause? + Block
WhenClause			:= "when" + Expression
Lambda				:= "lambda" + DeclarationHeader + (: + Identifier)? + Block
DeclarationTerm		:= (Identifier + "?"?) | (String + "?"?) | ( "(" + Identifier + (: + Identifier)? + ")" )
Identifier			:= [a-z, A-Z, any non-operator symbol][any non-delimeter symbol]*
Block				:= { + Statement+ + }
Statement			:= Let | If | Invokation + ; | DynamicInvokation + ; | BracketInvokation + ; | Control | LocalDeclaration
Let					:= "let" + (Identifier | MemberAccess | Indexer) + "=" + Expression + ;
If					:= "if" + Expression + Block
MemberAccess		:= Term + (StaticMember | DynamicMember)
StaticMember		:= "." + Identifier
DynamicMember		:= "?" + Identifier + ":" + Term
Indexer				:= Term + @ + Term
Expression			:= Term | BinaryOperation | New | Lambda
Term				:= Parenthetical | Identifier | Number | BasicString | ComplexString 
						| MemberAccess | Indexer | BracketInvokation | DynamicInvokation | Cast | List
Parenthetical		:= "(" + Expression + ")"
Cast				:= Term + : + Identifier	//Tell static type checking to go fuck itself.
BinaryOperation		:= Term + Operator + Term
Invokation			:= Term+
BracketInvokation	:= "[" + Invokation + "]"
DynamicInvokation	:= ":" + BracketInvokation //To be replaced by 'invoke' control
Control				:= Invokation + (Block | ;)
Operator			:= Any of operators specified in operator table
BasicString			:= Ordinary quote-delimited string				 
ComplexString		:= @ + \" + ( Text | EmbeddedExpression )* + \"		
Text				:= Any sequence of characters except [ or ", matched greedily.
EmbeddedExpression	:= [ + Expression + ]
LocalDeclaration	:= "var" + Identifier + (: + Identifier)? + ("=" + Expression)? + ;
TypeDeclaration		:= "type" + Identifier + (: + Identifier)? + { + MemberDeclaration* + }
MemberDeclaration	:=  "var" + Identifier + (: + Identifier)? + ;
New					:= "new" + Identifier + InitializerBlock?
InitializerBlock	:= { + InitializerItem* + }
InitializerItem		:= "let" + Identifier + "=" + Expression + ;
List				:= { + Term* + }
Include				:= "include" + BasicString

Delimeter symbols	:= []{}()\s\t\r\n.:;

Default operator table
0	||
0	&&
0	==
0	!=
0	<
0	>
0	<=
0	>=

1	+
1	-
1	&
1	|

2	*
2	/
2	%

Default Controls

foreach (x) in (list)
foreach (x) from (min) to (max)
while (x)
consider (x)
invoke [x]

Default Types
VOID
GENERIC
NUMBER
STRING
COMPLEXSTRING
BOOLEAN
LIST


Conversion Macros

A macro with the signature "convert (x:A) to B : B" will be invoked to automatically convert 
	an object of type A to B where appropriate.

An example:
macro convert (cstr:complexstring) to string : string {
	return (:[cstr]):string;
}


Member Access Macros

A macro with the signature 'get (x:string) from (y:A)' will be invoked to automatically query members. Without it, 
	the default mechanism is used. This does not serve much purpose when defined in script, but the 
	enclosing system can use it to implement member access in a generic way.

Standard Macro Patterns
GET (M:STRING) FROM (O:?) : ?
SET (M:STRING) ON (O:?) TO (V:?) : VOID
GET ? FROM (O:?) : ?
SET ? ON (O:?) TO (V:?) : VOID
GET AT (N:?) FROM (O:?): ?
SET AT (N:?) IN (O:?) TO (V:?) : VOID
CONVERT (O:?) TO ? : ?

