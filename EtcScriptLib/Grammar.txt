TODO List:
	*Implement global variables
	*Compress string table
	Github page w/ examples
	IDE or line-by-line debugger?
	Namespaces?
	String Library + Documentation

EtcScript Grammar

Script				:= (MacroDeclaration | RuleDeclaration | TypeDeclaration | GlobalDeclaration)*
GlobalDeclaration	:= "global" + Identifier + (: + Identifier)? + ;
MacroDeclaration	:= "macro" + DeclarationHeader + (: + Identifier)? + Block
DeclarationHeader	:= (DeclarationTerm)*
RuleDeclaration		:= "rule" + DeclarationHeader + WhenClause? + Block
WhenClause			:= "when" + Expression
Lambda				:= "lambda" + DeclarationHeader + (: + Identifier)? + Block
DeclarationTerm		:= (Identifier + "?"?) | (String + "?"?) | ( "(" + Identifier + (: + Identifier)? + ")" )
Identifier			:= [a-z, A-Z, any non-operator symbol][any non-delimeter symbol]*
Block				:= { + Statement+ + }
Statement			:= Let | If | Invokation + ; | DynamicInvokation + ; | BracketInvokation + ; | Control | LocalDeclaration
Let					:= "let" + (Identifier | MemberAccess) + "=" + Expression + ;
If					:= "if" + Expression + Block
MemberAccess		:= Term + (StaticMember | DynamicMember)
StaticMember		:= "." + Identifier
DynamicMember		:= "?" + Identifier + ":" + Term
Expression			:= Term | BinaryOperation | New | Lambda
Term				:= Parenthetical | Identifier | Number | BasicString | ComplexString 
						| MemberAccess | BracketInvokation | DynamicInvokation | Cast
Parenthetical		:= "(" + Expression + ")"
Cast				:= Parenthetical + : + Identifier	//Tell static type checking to go fuck itself.
BinaryOperation		:= Term + Operator + Term
Invokation			:= Term+
BracketInvokation	:= "[" + Invokation + "]"
DynamicInvokation	:= ":" + BracketInvokation
Control				:= Invokation + (Block | ;)
Operator			:= Any of operators specified in operator table
BasicString			:= Ordinary quote-delimited string				//This is a 'future' feature and will require lambda capture 
ComplexString		:= @ + \" + ( Text | EmbeddedExpression )* + \"		//to implement
Text				:= Any sequence of characters except [ or ", matched greedily.
EmbeddedExpression	:= [ + Expression + ]
LocalDeclaration	:= "var" + Identifier + (: + Identifier)? + ("=" + Expression)? + ;
TypeDeclaration		:= "type" + Identifier + { + MemberDeclaration* + }
MemberDeclaration	:=  "var" + Identifier + (: + Identifier)? + ;
New					:= "new" + Identifier + InitializerBlock?
InitializerBlock	:= { + InitializerItem* + }
InitializerItem		:= "let" + Identifier + "=" + Expression + ;

Delimeter symbols	:= []{}()\s\t\r\n.:;

Default operator table
0	||
0	&&
0	==
0	!=
0	<
0	>
0	<=
0	>=

1	+
1	-
1	&
1	|

2	*
2	/
2	%

Default Controls

foreach (x) in (list)
foreach (x) from (min) to (max)
while (x)
consider (x)

Default Types
VOID
GENERIC
NUMBER
STRING
COMPLEXSTRING
BOOLEAN
LIST


Conversion Macros

A macro with the signature "convert (x:A) to B : B" will be invoked to automatically convert 
	an object of type A to B where appropriate.

An example:
macro convert (cstr:complexstring) to string : string {
	return (:[cstr]):string;
}


Member Access Macros

A macro with the signature 'get (x) from (y:A)' will be invoked to automatically query members. Without it, 
	the default mechanism is used. This does not serve much purpose when defined in script, but the 
	enclosing system can use it to implement member access in a generic way.